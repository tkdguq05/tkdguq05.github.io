<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>Category: cs - Unreasonable Effectiveness</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Unreasonable Effectiveness"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Unreasonable Effectiveness"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="Unreasonable Effectiveness"><meta property="og:url" content="http://tkdguq05.github.io/"><meta property="og:site_name" content="Unreasonable Effectiveness"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://tkdguq05.github.io/img/og_image.png"><meta property="article:author" content="SangHyub Lee, Jose"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://tkdguq05.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://tkdguq05.github.io"},"headline":"Unreasonable Effectiveness","image":["http://tkdguq05.github.io/img/og_image.png"],"author":{"@type":"Person","name":"SangHyub Lee, Jose"},"publisher":{"@type":"Organization","name":"Unreasonable Effectiveness","logo":{"@type":"ImageObject"}},"description":null}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Unreasonable Effectiveness</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">cs</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-28T12:55:59.000Z" title="2019. 1. 28. 오후 9:55:59">2019-01-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-02-24T03:18:07.000Z" title="2020. 2. 24. 오후 12:18:07">2020-02-24</time></span><span class="level-item"><a class="link-muted" href="/categories/cs/">cs</a><span> / </span><a class="link-muted" href="/categories/cs/python/">python</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/28/class/">클래스에 대해서 알아보자</a></p><div class="content"><span id="more"></span>
<p>Class는 객체지향 프로그래밍에서 가장 중요하고도 까다롭다.<br>흔히 말하는 상속이 무엇인지, 어떤 상황에서 상속을 하는지, 상속을 할 수 없을 때는<br>객체 관계를 어떻게 표현하는지 알아보자.</p>
<h1 id="클래스-관계"><a href="#클래스-관계" class="headerlink" title="클래스 관계"></a>클래스 관계</h1><p>클래스 관계를 나타내는 방법으로 IS-A와 HAS-A가 있다.</p>
<h3 id="1-1-IS-A-상속"><a href="#1-1-IS-A-상속" class="headerlink" title="1.1 IS-A : 상속"></a>1.1 IS-A : 상속</h3><p>IS-A는 ‘은 ~의 한 종류다’를 말한다. 노트북과 컴퓨터를 예를 들어보자. 노트북은 컴퓨터의 한 종류일까?<br>그렇다. 이런 관계일 경우 Computer와 laptop 클래스는 IS-A관계라고 말할 수 있다.<br>IS-A관계 인지 아닌지 분간이 안된다면, ‘한 종류다’라는 의미가 있는지 생각해 보자.</p>
<p>이런 IS-A관계를 프로그램에서 표현할 때는 상속을 사용한다. 상속은 IS-A관계에서 설계가 쉽다.</p>
<p>상속을 하는 클래스와 상속을 받는 클래스를 나눠 볼 수 있는데 표현은 다음과 같다.</p>
<p><strong>상속을 하는 클래스</strong></p>
<ul>
<li>기본 클래스</li>
<li>부모 클래스</li>
<li>슈퍼 클래스</li>
</ul>
<p><strong>상속을 받는 클래스</strong></p>
<ul>
<li>파생 클래스</li>
<li>자식 클래스</li>
<li>서브 클래스</li>
</ul>
<p>코드로 laptop과 computer 클래스를 설계해 보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpu, ram</span>):</span><br><span class="line">    	self.CPU = cpu</span><br><span class="line">    	self.RAM = ram</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">browse</span>(<span class="params">self</span>):</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&#x27;browse&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;work&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>이 코드에서 인스턴스 멤버는 CPU와 RAM이다. 인스턴스 메서드는 browse()와 일을 하는 work()이다.<br>노트북은 컴퓨터의 모든 멤버와 메서드를 가진다. 노트북에도 CPU와 RAM이 있고, 같은 일을 하기 때문이다.<br><strong>어떤 객체가 다른 객체의 모든 특성과 기능을 가진 상태에서 그 외에 다른 특성이나 기능을 가지고 있다면 상속해서 쓰는게 편하다.</strong></p>
<p>노트북 클래스를 설계해보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span>(<span class="title class_ inherited__">Computer</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpu, ram, battery</span>):</span><br><span class="line">    	<span class="built_in">super</span>().__init__(cpu, ram)</span><br><span class="line">        self.battery = battery</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self, to</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;move to &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(to))</span><br></pre></td></tr></table></figure>
<p>노트북의 클래스 옆에 Computer가 붙은게 보인다. 이는 컴퓨터 클래스를 상속하겠다는 뜻이다.<br>이렇게 되면 노트북은 컴퓨터 클래스가 가진 모든 멤버와 메서드를 가지게 된다. 노트북도 browse()와<br>work()가 가능하다는 말이다. 확실히 손이 덜 피곤하다는 게 느껴질 것이다.</p>
<p>super는 무엇일까? 이것은 기본 클래스를 의미한다. 기본 클래스는 위에서 써놨듯이, 상속을 하는 클래스, 즉<br>컴퓨터 클래스를 가리킨다. CPU와 RAM은 기본 클래스의 생성자를 이용해 초기화가 되었기 때문에 남은 한 멤버인 battery만 할당해 주면 된다.</p>
<p>그리고 노트북에만 있는 move메서드를 입력해준다. 이렇게 되면, 노트북만의 메서드를 하나 갖게 된다.</p>
<p>테스트 코드는 다음과 같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	lap = Laptop(<span class="string">&#x27;intel&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;powerful&#x27;</span>)</span><br><span class="line">    lap.browse()</span><br><span class="line">    lap.work()</span><br><span class="line">    lap.move(<span class="string">&#x27;office&#x27;</span>) </span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1.2 HAS-A : 합성 또는 통합</span></span><br><span class="line">HAS-A관계는 <span class="string">&#x27;~이 ~을 가진다 혹은 포함한다&#x27;</span>를 의미한다. Computer는 CPU와 RAM을 가지는데,</span><br><span class="line">여기서 이 관계를 HAS-A관계라고 부를 수 있다.</span><br><span class="line"></span><br><span class="line">경찰과 총의 관계를 생각해보자. 경찰은 총을 가지고 있다. 경찰과 총은 HAS-A관계가 성립한다.</span><br><span class="line">주의해야할 점이 있는데, HAS-A관계에는 합성과 통합이라는 표현방법이 존재한다.</span><br><span class="line"></span><br><span class="line">컴퓨터와 CPU의 관계를 합성으로 표현하고, 경찰과 총의 관계를 통합으로 표현해보자.</span><br><span class="line">``` python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> :</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RAM</span> :</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> :</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    	self.cpu = CPU()</span><br><span class="line">        self.ram = RAM()</span><br></pre></td></tr></table></figure>

<p>Computer는 인스턴스 멤버 cpu를 가진다. 생성자에서 CPU 객체를 생성해서 멤버 cpu에게 할당한다.<br>이렇게 되면 Computer라는 객체가 생성이 될 때, CPU와 RAM이 같이 생성이 되고, 사라질때 같이 사라지게 된다.</p>
<p>이 둘의 관계는 매우 강한 관계를 맺고 있다고 할 수 있다. 이런 관계를 <code>합성</code>이라고 한다.</p>
<p>경찰과 총의 관계를 살펴보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> :</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kind</span>):</span><br><span class="line">    	self.kind = kind</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bang</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;bang bang&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Police</span> :</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    	self.gun = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire_gun</span>(<span class="params">self, gun</span>):</span><br><span class="line">    	self.gun = gun</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release_gun</span>(<span class="params">self</span>):</span><br><span class="line">    	gun = self.gun</span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> gun</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shoot</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">if</span> self.gun:</span><br><span class="line">        	self.gun.bang()</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unable to shoot&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>이 관계에서는 Police 객체가 만들어질 때 Gun 객체를 가지고 있지 않다. 이후 acquire_gun()메서드를<br>통해서 Gun 객체를 멤버로 가지게 된다. 이 관계 역시 HAS-A이다. 또한 release_gun()으로 가진 총을<br>반납할 수도 있다. 이 두 메서드를 이용해 총을 가진 경찰, 총이 없는 경찰 모두를 표현할 수 있다.</p>
<p>하지만 컴퓨터 클래스와 다른 점은, 경찰은 언제든지 Gun을 가질 수 있고 해제할 수 있다는 점이다.<br>관계가 컴퓨터에 비해 훨씬 약하다는 느낌이 들 것이다. 이런 약한 관계를 <code>통합</code>이라고 부른다.</p>
<h2 id="2-메서드-오버라이딩과-다형성-Polymorphism"><a href="#2-메서드-오버라이딩과-다형성-Polymorphism" class="headerlink" title="2. 메서드 오버라이딩과 다형성(Polymorphism)"></a>2. 메서드 오버라이딩과 다형성(Polymorphism)</h2><p>OOP에서 가장 중요한 개념은 다형성이다(polymorphism). 나는 이 ‘폴리몰피즘’에 대해 노이로제가 걸렸었던 적이 있다.<br>고려대에서 진행한 <code>Bigdata X Campus</code> 교육에서였다. 파이썬 강의를 들으면서 강사는 <del>“뽈리몰피즘! 뽈리몰피즘이 중요하죠!”</del> 라고 열변을 토했고, 매 강의마다 항상 강조되었었다.<br>‘도대체 polymorphism이 뭐길래’ 라는 생각이 들었었고, 이 책을 보면서 그 갈증이 어느정도 해결이 되었다.</p>
<p>다형성이란 ‘상속 관계에 있는 다양한 클래스의 객체에서 같은 이름의 메서드를 호출할 때, 각 객체가 서로 다르게 구현된 메서드를 호출함으로써 서로 다른 행동, 기능, 결과를 가져오는 것’을 의미한다. 이를 구현하기 위해서는 파생 클래스 안에서 상속받은 메서드를 다시 구현하는 메서드 오버라이딩이라고 부른다.</p>
<h3 id="2-1-메서드-오버라이딩"><a href="#2-1-메서드-오버라이딩" class="headerlink" title="2.1 메서드 오버라이딩"></a>2.1 메서드 오버라이딩</h3><p>먼저 코드를 살펴보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CarOwner</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">    	self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">concentrate</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; can not do anything else&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, owner_name</span>):</span><br><span class="line">    	self.owner = CarOwner(owner_name)</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">    	self.owner.concentrate()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; is driving now.&#x27;</span>.<span class="built_in">format</span>(self.owner.name))</span><br></pre></td></tr></table></figure>
<p>drive()메서드를 보면 Car 객체는 반드시 차 주인인 CarOwner객체가 운정해야 하고 차 주인은 운전에만<br>집중해야 한다. drive()메서드가 나오자마자 CarOwner객체의 concentrate()메서드를 호출해서 차 주인이 운전외에는 아무것도 못하게 한다.</p>
<p>이번에는 자율주행차를 만들어보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfDrivingCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;Car is driving by itself&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>자율주행차에는 상속받은 drive가 어울리지 않는다. 새롭게 바꿔줄 필요가 있다. drive()메서드를 제외하고는 나머지 멤버와 메서드는 그대로 사용한다. 이러한 경우에는 drive()메서드만 클래스 안에서 재정의해준다.</p>
<p>이렇게 클래스 안에서, 맘에 들지 않는 메서드를 재정의 하는 것을 <code>메서드 오버라이딩</code>이라고 한다.<br>자율주행차의 차 주인은 더 이상 운전에 집중하지 않아도 된다. 따라서 오버라이딩된 drive()메서드에서는<br>concentrate()를 호출하지 않는다.</p>
<p>여기서 정리해보자면, drive()메서드는 같은 이름이지만 객체에 따라 다른 기능을 하게 된다. 이처럼<br>같은 이름의 메서드를 호출해도 호출한 객체에 따라 다른 결과를 내는 것을 <code>다형성</code>이라고 한다.</p>
<h3 id="2-2-다형성"><a href="#2-2-다형성" class="headerlink" title="2.2 다형성"></a>2.2 다형성</h3><p>다형성에 대해 좀 더 깊이 알아보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;eat something&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;eat meat&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;eat grass&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;eat meat and grass&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	animals = []</span><br><span class="line">    animals.append(Lion())</span><br><span class="line">    animals.append(Cow())</span><br><span class="line">    animals.append(Human())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    	animal.eat()</span><br></pre></td></tr></table></figure>
<p>이 코드의 Animal 클래스에는 eat()메서드가 있다. 모든 동물은 반드시 먹어야 한다는 가정이다.<br>하지만 동물마다 먹는 종류는 다르기 때문에 육식 동물의 대표로 사자를 설정했고, 초식 동물의 대표로 소를<br>설정했다. 그리고 잡식 동물로 사람을 설정했다. <del>나는 소고기를 쌈싸먹는 것을 좋아한다.</del></p>
<p>코드의 반복문의 마지막 부분에서 animal.eat()은 다형성을 구현한 부분이다. animals 리스트에서 객체를 하나씩 불러와 eat()메서드를 호출할 때, 메서드를 호출한 쪽에서는 육식동물인지 초식동물인지 잡식인지 고민할 필요가 없다. 각 객체는 오버라이딩된 메서드를 호출하기 때문이다.</p>
<p>그렇게 되면 여기서는 그냥 무엇인가를 먹는 동물은 없다. 그러니까 Animal은 eat something하는 게 있는데 사용하는 동물이 아무도 없다. 안써버리자니 문제가 되고, 뭔가 낭비같다.</p>
<p>이럴 때는 Animal 클래스를 추상 클래스로 만들면 된다.</p>
<p>추상 클래스는 독자적으로 인스턴스를 만들 수 없고 함수의 몸체가없는 추상 메서드를 하나 이상 가지고 있어야 한다. 또한 이 클래스를 상속받는 파생 클래스는 추상 메서드를 반드시 오버라이딩 해야한다. 당연히 아무것도 없으니까!</p>
<p>Animal을 추상 클래스로 변경해보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(metaclass = ABCMeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">pass</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>먼저 abc모듈을 가져온다.(abstract base class) 그 후 @abstractmehod 데코레이터를 붙여준다.<br>여기서 메서드 구현하는 부분을 pass로 비워두면 eat()은 추상 메서드가 된다.<br>이제 Animal을 상속받는 모든 파생 클래스는 eat()을 오버라이딩 해야한다.</p>
<h2 id="클래스-설계-예제"><a href="#클래스-설계-예제" class="headerlink" title="클래스 설계 예제"></a>클래스 설계 예제</h2><p>클래스를 설계할 때느느 다음 두가지를 고려해야 한다.</p>
<ul>
<li>공통 부분을 기본 클래스로 묶는다.</li>
<li>부모가 추상클래스인 경우를 제외하고, 파생 클래스에서 기본 클래스의 여러 메서드를 오버라이딩한다면 파생 클래스는 만들지 않는 것이 좋다.</li>
</ul>
<h3 id="Character-클래스-만들기"><a href="#Character-클래스-만들기" class="headerlink" title="Character 클래스 만들기"></a>Character 클래스 만들기</h3><p>게임 캐릭터를 만들어보면서 클래스를 정리해보자.<br>게임에 등장하는 캐릭터는 플레이어 우리 자신과 몬스터이다.<br>모든 캐릭터(추상 클래스)는 다음과 같은 특성을 지닌다.</p>
<ul>
<li>인스턴스 멤버 : 이름, 체력, 공격력을 가진다.</li>
<li>인스턴스 메서드 : 공격, 공격당했을 때는 피해를 입는다.(모두 추상 메서드로 구현한다.)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span>(metaclass = ABDMeta):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hp, power</span>):</span><br><span class="line">    	self.name = name</span><br><span class="line">        self.hp = hp</span><br><span class="line">        self.power = power</span><br><span class="line">        </span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_damage</span>(<span class="params">self, power, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;&#123;&#125; : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, self.HP)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Player-클래스-만들기"><a href="#3-2-Player-클래스-만들기" class="headerlink" title="3.2 Player 클래스 만들기"></a>3.2 Player 클래스 만들기</h3><p>플레이어는 다음과 같은 특성이 있다.</p>
<ul>
<li>추가되는 멤버 : 플레이어는 다양한 공격 종류를 담을 수 있는 기술 목록이 있다.</li>
<li>attack : 플레이어는 공격할 때 공격 종류가 기술 목록 안에 있다면 상대 몬스터에게 피해를 입힌다.</li>
<li>get_damage : 플레이어가 피해를 입을 때 몬스터의 공격 종류가 플레이어의 기술 목록에 있다면 몬스터의 공격력이 반감되어 hp의 절반만 깎인다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(<span class="title class_ inherited__">Character</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;player&#x27;</span>, hp = <span class="number">100</span>, power = <span class="number">10</span>, *attack_kinds</span>):</span><br><span class="line">    	<span class="built_in">super</span>().__init__(name, hp, power)</span><br><span class="line">        </span><br><span class="line">        self.skills = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> attack_kind <span class="keyword">in</span> attack_kinds:</span><br><span class="line">        	self.skills.append(attack_kind)</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">if</span> attack_kind <span class="keyword">in</span> self.skills:</span><br><span class="line">        	other.get_damage(self.power, attack_kind)</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_damage</span>(<span class="params">self, power, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">if</span> attack_kind <span class="keyword">in</span> self.skills:</span><br><span class="line">        	self.HP -= (poewr/<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span> : </span><br><span class="line">        	self.HP -= power</span><br></pre></td></tr></table></figure>
<p>코드에서 살펴보면 플레이어는 캐릭터를 상속했다.</p>
<h3 id="3-3-Monster-IceMonster-FireMonster-클래스-만들기"><a href="#3-3-Monster-IceMonster-FireMonster-클래스-만들기" class="headerlink" title="3.3 Monster, IceMonster, FireMonster 클래스 만들기"></a>3.3 Monster, IceMonster, FireMonster 클래스 만들기</h3><p>몬스터에는 불 몬스터와 얼음 몬스터가 있으며 다음과 같은 특징이 있다.</p>
<ul>
<li>추가되는 멤버 : 공격 종류를 가진다. 불 몬스터는 Fire, 얼음 몬스터는 Ice를 가진다.</li>
<li>공통 메서드 :  두 몬스터는 같은 행동을 한다.<ul>
<li>attack : 공격 종류가 몬스터의 속성과 같다면 공격한다.</li>
<li>get_damage : 몬스터는 자신과 속성이 같은 공격을 당하면 체력이 오히려 공격력만큼 증가한다. 그렇지 않으면 체력이 공격력만큼 감소한다.</li>
</ul>
</li>
</ul>
<p>여기서 고민해야 할 점이 있다. FireMonster 클래스와 IceMonster 클래스를 Character 클래스에서 상속받아 구현할지, Moster 클래스라는 부모 클래스를 따로 만들어야 할지.<br>설명에 따르면 추가되는 멤버도 겹치고, fireball()메서드를 제외한 나머지 메서드도 겹친다. 그러면 공통되는 부분을 기본 클래스로 만들고 이를 상속받는 게 좋을 것 같다.</p>
<p>몬스터를 만들고 몬스터는 캐릭터 클래스를 상속받을 것이다. 그리고 몬스터 클래스를 상속받아 각 몬스터를 만들어보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span>(<span class="title class_ inherited__">Character</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hp, power</span>):</span><br><span class="line">    	<span class="built_in">super</span>().__init__(name, hp, power):</span><br><span class="line">    	self.attack_kind = <span class="string">&#x27;None&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">if</span> self.attack_kind == attack_kind:</span><br><span class="line">        	other.get_damage(self.power, attack_kind)</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_damage</span>(<span class="params">self, power, attack_kind</span>):</span><br><span class="line">    	<span class="keyword">if</span> self.attack_kind == attack_kind:</span><br><span class="line">        	self.HP += power</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">        	self.HP -= power</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_attack_kind</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> self.attack_kind</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IceMonster</span>(<span class="title class_ inherited__">Monster</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Ice monster&#x27;</span>, hp = <span class="number">50</span>, power = <span class="number">10</span></span>)</span><br><span class="line">    	<span class="built_in">super</span>().__init__(name, hp, power)</span><br><span class="line">        self.attack_kind = <span class="string">&#x27;ICE&#x27;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireMonster</span>(<span class="title class_ inherited__">Monster</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Fire monster&#x27;</span>, hp= <span class="number">50</span>, power = <span class="number">20</span></span>)</span><br><span class="line">    	<span class="built_in">super</span>().__init__.(name, hp, power)</span><br><span class="line">        self.attack_kind = <span class="string">&#x27;FIRE&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">firebreath</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;firebreath&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>불 몬스터와 얼음 몬스터는 몬스터 클래스를 상속 받았고 추가되거나 변경되는 부분만 수정했다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	player = Player(<span class="string">&#x27;sword master&#x27;</span>, <span class="number">100</span>, <span class="number">30</span>, <span class="string">&#x27;ICE&#x27;</span>)</span><br><span class="line">    monsters = []</span><br><span class="line">    monsters.append(IceMonster())</span><br><span class="line">    monsters.append(FireMonster())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters : </span><br><span class="line">	    <span class="built_in">print</span>(monster)</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">    	player.attack(monster, <span class="string">&#x27;ICE&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;after the plater attacked&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">    	<span class="built_in">print</span>(monster)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(player)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">    	monster.attack(player, monster.get_attack_kind())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after monsters attacked&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(player)</span><br></pre></td></tr></table></figure>

<h2 id="4-연산자-오버로딩"><a href="#4-연산자-오버로딩" class="headerlink" title="4. 연산자 오버로딩"></a>4. 연산자 오버로딩</h2><p>연산자 오버로딩은 클래스 안에서 메서드로 연산자를 새롭게 구현하는 것으로 다형성의 특별한 형태이다.<br>연산자 오버로딩을 사용하면 다른 객체나 일반적인 피연산자와 연산을 할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">    	self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_point</span>(<span class="params">self, x, y</span>):</span><br><span class="line">    	self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_point</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> self.x, self,y</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;(&#123;x&#125;, &#123;y&#125;)&#x27;</span>.<span class="built_in">format</span>(x = self.x, y = self.y)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	p1 = Point(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    p2 = p1 + <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(p2)</span><br></pre></td></tr></table></figure>
<p>결과를 실행해 보면 에러가 발생할 것이다. Point와 int 객체 사이는 덧셈을 할 수 없다고 나온다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, n</span>):</span><br><span class="line">    	x = self.x + n</span><br><span class="line">        y = self.y + n</span><br><span class="line">        <span class="keyword">return</span> Point(x,y)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	p1 = Point(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    p2 = p1 + <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br></pre></td></tr></table></figure>

<p>이렇게 add메서드를 추가해보자. 예약한 함수를 사용해서 x좌표와 y좌표에 인자 n을 더한 새로운 x와 y로<br>새로운 객체를 만들어 반환한다.<br>실행 결과는 (5,5)가 나오게 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	p1 = Point(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    p2 = <span class="number">3</span> + p1</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br></pre></td></tr></table></figure>

<p>계산이 안된다. int와 Point의 순서가 바뀌면 에러가 발생한다.<br>연산자 오버로딩을 하나 더 해주자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, n</span>):</span><br><span class="line">    	x = self.x + n</span><br><span class="line">        y = self.y + n</span><br><span class="line">        <span class="keyword">return</span> Point(x,y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	p1 = Point(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    p2 = <span class="number">3</span> + p1</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5,5)</span><br></pre></td></tr></table></figure>
<p><code>__radd__()</code>메서드를 이용해서 연산이 돌아가도록 만들었다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-19T04:45:26.000Z" title="2019. 1. 19. 오후 1:45:26">2019-01-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-02-24T03:18:41.000Z" title="2020. 2. 24. 오후 12:18:41">2020-02-24</time></span><span class="level-item"><a class="link-muted" href="/categories/cs/">cs</a><span> / </span><a class="link-muted" href="/categories/cs/python/">python</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/19/float/">Python의 실수형에 대해서 알아보자</a></p><div class="content"><span id="more"></span>
<h1 id="컴퓨터-사이언스-부트캠프-with-Python"><a href="#컴퓨터-사이언스-부트캠프-with-Python" class="headerlink" title="컴퓨터 사이언스 부트캠프 with Python"></a>컴퓨터 사이언스 부트캠프 with Python</h1><h2 id="1-실수-연산의-함정"><a href="#1-실수-연산의-함정" class="headerlink" title="1. 실수 연산의 함정"></a>1. 실수 연산의 함정</h2><p>데이터 사이언스 공부를 하다보면 가끔 머리로 이해되지 않는 것이 생기곤 한다. 그 중 하나가 실수 연산에 대한 것이다.<br>다음 예를 살펴보자</p>
<p>python(3.6.4)으로 다음과 같이 입력하자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0.01</span></span><br><span class="line">result = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	result += a </span><br><span class="line">result</span><br></pre></td></tr></table></figure>


<p>result는 값이 어떻게 나오게 될까?<br>위의 코드는 쉽게 말하자면 0.01을 100번 더한 것과 다를 게 없다.<br>그렇다면 답은 1일 것이다. 하지만 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result </span><br><span class="line"><span class="number">1.0000000000000007</span></span><br></pre></td></tr></table></figure>
<p>답은 1이 아니다. 만약 내가 조건문을 이용해서<br><code>1==result</code> 판단을 내렸다면 결과는 False로 나올 것이다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0.015625</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	result += a</span><br><span class="line">result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">1.5625</span></span><br></pre></td></tr></table></figure>
<p>그런데 이번 경우에는 생각과 같이 1.5625라는 결과가 나온다. 왜 갑자기 오차 하나 없이 깔끔하게 값이 나오는 것일까?<br>왜 이런 일이 발생하는 것일까?</p>
<h2 id="2-부동소수점"><a href="#2-부동소수점" class="headerlink" title="2. 부동소수점"></a>2. 부동소수점</h2><p>이 현상에 대해 이해하기 위해 부동소수점에 대해서 이해를 해야한다.</p>
<p>부동소수점에서 ‘부’는 부유한다는 말, 즉 떠다닌다는 말이다. 123.456을 다르게 표현해 보는 경우를 생각해보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.456</span> = <span class="number">1.23456</span> * <span class="number">10</span>^<span class="number">2</span></span><br><span class="line"><span class="number">123.456</span> = <span class="number">12.3456</span> * <span class="number">10</span> </span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>위의 예시 말고도 다양한 방식이 있다. 소숫점이 둥둥 떠다니는 것 같이 움직인다. 그래서 이러한 실수 표현 방식을 부동소수점이라고 부른다.</p>
<h2 id="3-단정도와-배정도"><a href="#3-단정도와-배정도" class="headerlink" title="3. 단정도와 배정도"></a>3. 단정도와 배정도</h2><p>단정도(single-precision)는 실수를 32비트로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성되어 있다.<br>배정도(double-precision)는 실수를 64비트로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성되어 있다.<br>배정도가 단정도보다 두 배 정도의 비트 수가 많은데, 비트 수가 많은 만큼 정밀도가 높다고 할 수 있겠다. <strong>파이썬은 배정도를 사용한다.</strong></p>
<h2 id="4-1바이트-실수-자료형-설계하기"><a href="#4-1바이트-실수-자료형-설계하기" class="headerlink" title="4. 1바이트 실수 자료형 설계하기"></a>4. 1바이트 실수 자료형 설계하기</h2><p>$$\pm 1.man \times 2^{(exp-bias)}$$</p>
<p>위의 수식은 실수 자료형을 표현한 수식이다. </p>
<p>1.man은 가수, 2는 밑수, exp-bias는 지수를 의미한다.</p>
<p>이 식을 이용해 7.75라는 10진수 실수를 1바이트 부동소수점으로 표현해보자.</p>
<h4 id="4-1-10진수-실수를-2진수-실수로-바꾸기"><a href="#4-1-10진수-실수를-2진수-실수로-바꾸기" class="headerlink" title="4.1 10진수 실수를 2진수 실수로 바꾸기"></a>4.1 10진수 실수를 2진수 실수로 바꾸기</h4><p>$$7.75 = 4 + 2 +1 +0.5 + 0.25 $$<br>$$= 2^2 + 2^1 + 2^0 + 2^{-1} + 2^{-2}$$<br>$$=111.11$$<br>2진수로 바꾸면 111.11이란 값이 나온다.</p>
<h4 id="4-2-정규화"><a href="#4-2-정규화" class="headerlink" title="4.2 정규화"></a>4.2 정규화</h4><p>아 숫자를 정규화 해보자. 정규화란, 소수점 왼쪽에 위치한 가수 부분을 밑수보다 작은 자연수가 되도록 만드는 것이다.<br>111.11을 정규화 하면 다음과 같다.</p>
<p>$$ 111.11 = 1.1111 \times 2^2$$</p>
<h4 id="4-3-메모리-구조"><a href="#4-3-메모리-구조" class="headerlink" title="4.3 메모리 구조"></a>4.3 메모리 구조</h4><p>정규화된 부동소수점 $1.111 \times 2^2$를 앞의 수식과 비교해 보면<br>man은 1111이고 exp-bias는 2이다.<br>이제 메모리 구조를 정하고 man과 exp값만 저장하면 설계가 끝난다.<br>이때 지수부와 가수부에 할당하는 비트 수에 따라 표현 범위와 정밀도가 결정된다.</p>
<p>1바이트 부동소수점 구조는 다음과 같다.<br>$$ 0 \ 0000 \ 000 \ [부호(sign) \ 지수부(exp) \ 가수부에서 \ man에 \ 해당되는 \ 부분] $$</p>
<ul>
<li>첫번째 비트 : 부호 0은 양수, 1은 음수</li>
<li>가운데 4비트 : 지수부에 해당하며 exp 값이다. <ul>
<li>0~15의 양수를 표현할 수 있다</li>
<li>$bias = 2^{지수의 비트수} -1$</li>
</ul>
</li>
<li>맨 뒤 3비트 :  가수부로 man 값을 저장함 </li>
</ul>
<p>$1.1111 \times 2^2$를 1바이트의 메모리 구조로 변경해 보자. </p>
<ul>
<li>부호비트는 0이다.</li>
<li>$exp-bias$는 2이다. $bias$값이 7이므로 $exp$는 9가 된다.이것을 이진수로 나타내면 $1001_{(2)}$가 된다.</li>
<li>가수부에 할당된 비트는 3비트이다. 1111을 3비트에 넣을때는 뒷자리 1을 생략한다. 가수부는 111이다.<br>$$ 0 \ 1001 \ 111 = 0100 \ 1111 $$<br>이것을 16진수로 나타내면 0x4f가 된다.<br><strong>정리하자면 10진수 7.75를 $ 0100 \ 1111 $로 나타낼 수 있고 이것을 다시 16진수로 나타내면 0x4f이다.</strong></li>
</ul>
<h4 id="4-4-1바이트-부동소수점의-표현-범위"><a href="#4-4-1바이트-부동소수점의-표현-범위" class="headerlink" title="4.4 1바이트 부동소수점의 표현 범위"></a>4.4 1바이트 부동소수점의 표현 범위</h4><ul>
<li>표현할 수 있는 가장 작은 수(지수부0001)<ul>
<li>$1.0000 \times = 0.0156256$</li>
</ul>
</li>
<li>표현할 수 있는 가장 큰 수(지수부 1110)<ul>
<li>$1.111 \times = 240$</li>
</ul>
</li>
</ul>
<p>단, 지수부 비트가 모두 0일때와 모두 1일때는 0.0, 정규화 불가능, 무한대, NaN 같은 특별한 상황이므로 제외한다.</p>
<h4 id="4-5-1바이트-부동소수점의-정밀도"><a href="#4-5-1바이트-부동소수점의-정밀도" class="headerlink" title="4.5 1바이트 부동소수점의 정밀도"></a>4.5 1바이트 부동소수점의 정밀도</h4><p>7.75를 변환하는 과정에서 3비트의 가수부데이터에 1을 누락해 가면서 가수부 공간에 담았던 것을 기억할 것이다.<br>1을 누락하게 되면 0x4f는 7.75를 완벽하게 표현하지 못하게 된다.<br>$$1.111 \times 2^2 = 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^{-1} = 7.5$$<br>여기서 0.25만큼 차이가 나게되고, 그만큼 정밀도도 떨어지게 된다.</p>
<h2 id="5-정밀도에-대한-고찰"><a href="#5-정밀도에-대한-고찰" class="headerlink" title="5. 정밀도에 대한 고찰"></a>5. 정밀도에 대한 고찰</h2><h4 id="5-1-엡실론"><a href="#5-1-엡실론" class="headerlink" title="5.1 엡실론"></a>5.1 엡실론</h4><p>실수 자료형에서 엡실론이란 1.0과 그 다음으로 표현 가능한 수 사이의 차이를 말한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.float_info.epsilion</span><br></pre></td></tr></table></figure>

<p>위 코드로 엡실론 값을 확인해 보자.<br>배정도의 가수부는 52비트인 것을 기억할 것이다. 1.0을 배정도에 맞춰 표현하면<br>$1.0000 ….. 0000(0:52개) \times 2^0$<br>배정도에서 1.0다음으로 표현할 수 있는 수는<br>$1.0000 ….. 0000(0:51개) \times 2^0$<br>두 수의 차이는<br>$1.0000 ….. 0000(0:51개) \times 2^0$<br>이 숫자를 10진수로 바꾸면 엡실론 값이 등장한다.<br>$2.220446049250313 \times 10^{-16}$</p>
<h4 id="5-2-엡실론과-정밀도"><a href="#5-2-엡실론과-정밀도" class="headerlink" title="5.2 엡실론과 정밀도"></a>5.2 엡실론과 정밀도</h4><p>엡실론을 이용하면 해당 실수 다음에 표현할 수 있는 수를 알아낼 수 있다.<br>9.25라는 수를 부동소수점 방식으로 표현하면 $1.00101 \times 2^3$이다.<br>여기서 지수부분만 떼서 엡실론을 구하면 이 실수와 다음 표현 가능한 수 사이의 차이를 구할 수 있다.<br>코드로 살펴보면,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">ep = sys.float_info.epsilion</span><br><span class="line">a= <span class="number">9.25</span></span><br><span class="line">diff = (<span class="number">2</span>**<span class="number">3</span>)*ep</span><br><span class="line">diff</span><br><span class="line">&gt;&gt;<span class="number">1.7763568394002504e-15</span></span><br><span class="line">b = a + diff</span><br><span class="line">b</span><br><span class="line">&gt;&gt;&gt;<span class="number">9.250000000000002</span></span><br></pre></td></tr></table></figure>

<p>0.000000000000002만큼 차이가 난다.</p>
<p>그렇다면 9.25에 diff보다 작은 값을 더하면 어떻게 될까?<br>추측으로는 9.25가 나올 것 같다.<br>확인해보자</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">9.25</span></span><br><span class="line">half_diff = diff/<span class="number">2</span></span><br><span class="line">c = a + half_diff</span><br><span class="line">a == c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>추측과 같이 half_diff를 더하더라도 값의 변화가 없다.<br><strong>diff보다 작은 값을 더한 수를 부동소수점 방식에서는 표현할 수 없다는 말이다.</strong><br>다르게 말하자면 정밀도가 떨어진다는 말이다.</p>
<p>다음의 내용은 <code>혼자서하는 괴발개발 블로그</code> <a target="_blank" rel="noopener" href="https://aisolab.github.io/computer%20science/2018/08/07/CS_Real-number">https://aisolab.github.io/computer%20science/2018/08/07/CS_Real-number</a> 에서 가져온 글이다.<br>다음의 방법을 이용하면 상대오차(relative error) 가 엡실론보다 작으면 서로 같은 수라고 판단하는 function을 만듦으로써 위와 같은 문제를 해결할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0.1</span> * <span class="number">3</span></span><br><span class="line">b = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>$$relative \ error = {\left\vert x - y\right\vert \over \max(\left\vert x \right\vert , \left\vert y \right\vert)}$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_equal</span>(<span class="params">a, b</span>):</span><br><span class="line">	ep = sys.float_info.epsilon</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt;= <span class="built_in">max</span>(<span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b)) * ep</span><br><span class="line"></span><br><span class="line">a = <span class="number">.1</span> * <span class="number">3</span></span><br><span class="line">b = <span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(is_equal(a,b))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



</div></article></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Unreasonable Effectiveness</a><p class="is-size-7"><span>&copy; 2023 SangHyub Lee, Jose</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>