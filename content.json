{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2019!","text":"첫 시작!데이터 사이언스 공부를 시작한지 1년이 훌쩍 넘었다. 기록을 하지 않으니까 정리도 되지않고 뭘 배웠는지도 잘 기억나지 않는다.꾸준히 기록해봐야겠다. 글을 꾸준히 쓰자 주 3회 목표","link":"/2019/01/11/2019/"},{"title":"클래스에 대해서 알아보자","text":"Class는 객체지향 프로그래밍에서 가장 중요하고도 까다롭다.흔히 말하는 상속이 무엇인지, 어떤 상황에서 상속을 하는지, 상속을 할 수 없을 때는객체 관계를 어떻게 표현하는지 알아보자. 클래스 관계클래스 관계를 나타내는 방법으로 IS-A와 HAS-A가 있다. 1.1 IS-A : 상속IS-A는 ‘은 ~의 한 종류다’를 말한다. 노트북과 컴퓨터를 예를 들어보자. 노트북은 컴퓨터의 한 종류일까?그렇다. 이런 관계일 경우 Computer와 laptop 클래스는 IS-A관계라고 말할 수 있다.IS-A관계 인지 아닌지 분간이 안된다면, ‘한 종류다’라는 의미가 있는지 생각해 보자. 이런 IS-A관계를 프로그램에서 표현할 때는 상속을 사용한다. 상속은 IS-A관계에서 설계가 쉽다. 상속을 하는 클래스와 상속을 받는 클래스를 나눠 볼 수 있는데 표현은 다음과 같다. 상속을 하는 클래스 기본 클래스 부모 클래스 슈퍼 클래스 상속을 받는 클래스 파생 클래스 자식 클래스 서브 클래스 코드로 laptop과 computer 클래스를 설계해 보자.12345678910class Computer: def __init__(self, cpu, ram): self.CPU = cpu self.RAM = ram def browse(self): print('browse') def work(self): print('work') 이 코드에서 인스턴스 멤버는 CPU와 RAM이다. 인스턴스 메서드는 browse()와 일을 하는 work()이다.노트북은 컴퓨터의 모든 멤버와 메서드를 가진다. 노트북에도 CPU와 RAM이 있고, 같은 일을 하기 때문이다.어떤 객체가 다른 객체의 모든 특성과 기능을 가진 상태에서 그 외에 다른 특성이나 기능을 가지고 있다면 상속해서 쓰는게 편하다. 노트북 클래스를 설계해보자1234567class Laptop(Computer): def __init__(self, cpu, ram, battery): super().__init__(cpu, ram) self.battery = battery def move(self, to): print('move to {}'.format(to)) 노트북의 클래스 옆에 Computer가 붙은게 보인다. 이는 컴퓨터 클래스를 상속하겠다는 뜻이다.이렇게 되면 노트북은 컴퓨터 클래스가 가진 모든 멤버와 메서드를 가지게 된다. 노트북도 browse()와work()가 가능하다는 말이다. 확실히 손이 덜 피곤하다는 게 느껴질 것이다. super는 무엇일까? 이것은 기본 클래스를 의미한다. 기본 클래스는 위에서 써놨듯이, 상속을 하는 클래스, 즉컴퓨터 클래스를 가리킨다. CPU와 RAM은 기본 클래스의 생성자를 이용해 초기화가 되었기 때문에 남은 한 멤버인 battery만 할당해 주면 된다. 그리고 노트북에만 있는 move메서드를 입력해준다. 이렇게 되면, 노트북만의 메서드를 하나 갖게 된다.","link":"/2019/01/28/class/"},{"title":"Python의 실수형에 대해서 알아보자","text":"컴퓨터 사이언스 부트캠프 with Python1. 실수 연산의 함정데이터 사이언스 공부를 하다보면 가끔 머리로 이해되지 않는 것이 생기곤 한다. 그 중 하나가 실수 연산에 대한 것이다.다음 예를 살펴보자 python(3.6.4)으로 다음과 같이 입력하자. 12345a = 0.01result = 0.0for i in range(100): result += a result result는 값이 어떻게 나오게 될까?위의 코드는 쉽게 말하자면 0.01을 100번 더한 것과 다를 게 없다.그렇다면 답은 1일 것이다. 하지만12&gt;&gt;&gt; result 1.0000000000000007 답은 1이 아니다. 만약 내가 조건문을 이용해서1==result 판단을 내렸다면 결과는 False로 나올 것이다. 1234a = 0.015625for i in range(100): result += aresult 1&gt;&gt;&gt;1.5625 그런데 이번 경우에는 생각과 같이 1.5625라는 결과가 나온다. 왜 갑자기 오차 하나 없이 깔끔하게 값이 나오는 것일까?왜 이런 일이 발생하는 것일까? 2. 부동소수점이 현상에 대해 이해하기 위해 부동소수점에 대해서 이해를 해야한다. 부동소수점에서 ‘부’는 부유한다는 말, 즉 떠다닌다는 말이다. 123.456을 다르게 표현해 보는 경우를 생각해보자123123.456 = 1.23456 * 10^2123.456 = 12.3456 * 10 ........ 위의 예시 말고도 다양한 방식이 있다. 소숫점이 둥둥 떠다니는 것 같이 움직인다. 그래서 이러한 실수 표현 방식을 부동소수점이라고 부른다. 3. 단정도와 배정도단정도(single-precision)는 실수를 32비트로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성되어 있다.배정도(double-precision)는 실수를 64비트로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성되어 있다.배정도가 단정도보다 두 배 정도의 비트 수가 많은데, 비트 수가 많은 만큼 정밀도가 높다고 할 수 있겠다. 파이썬은 배정도를 사용한다. 4. 1바이트 실수 자료형 설계하기$$\\pm 1.man \\times 2^{(exp-bias)}$$ 위의 수식은 실수 자료형을 표현한 수식이다. 1.man은 가수, 2는 밑수, exp-bias는 지수를 의미한다. 이 식을 이용해 7.75라는 10진수 실수를 1바이트 부동소수점으로 표현해보자. 4.1 10진수 실수를 2진수 실수로 바꾸기$$7.75 = 4 + 2 +1 +0.5 + 0.25 $$$$= 2^2 + 2^1 + 2^0 + 2^{-1} + 2^{-2}$$$$=111.11$$2진수로 바꾸면 111.11이란 값이 나온다. 4.2 정규화아 숫자를 정규화 해보자. 정규화란, 소수점 왼쪽에 위치한 가수 부분을 밑수보다 작은 자연수가 되도록 만드는 것이다.111.11을 정규화 하면 다음과 같다. $$ 111.11 = 1.1111 \\times 2^2$$ 4.3 메모리 구조정규화된 부동소수점 $1.111 \\times 2^2$를 앞의 수식과 비교해 보면man은 1111이고 exp-bias는 2이다.이제 메모리 구조를 정하고 man과 exp값만 저장하면 설계가 끝난다.이때 지수부와 가수부에 할당하는 비트 수에 따라 표현 범위와 정밀도가 결정된다. 1바이트 부동소수점 구조는 다음과 같다.$$ 0 \\ 0000 \\ 000 \\ [부호(sign) \\ 지수부(exp) \\ 가수부에서 \\ man에 \\ 해당되는 \\ 부분] $$ 첫번째 비트 : 부호 0은 양수, 1은 음수 가운데 4비트 : 지수부에 해당하며 exp 값이다. 0~15의 양수를 표현할 수 있다 $bias = 2^{지수의 비트수} -1$ 맨 뒤 3비트 : 가수부로 man 값을 저장함 $1.1111 \\times 2^2$를 1바이트의 메모리 구조로 변경해 보자. 부호비트는 0이다. $exp-bias$는 2이다. $bias$값이 7이므로 $exp$는 9가 된다.이것을 이진수로 나타내면 $1001_{(2)}$가 된다. 가수부에 할당된 비트는 3비트이다. 1111을 3비트에 넣을때는 뒷자리 1을 생략한다. 가수부는 111이다.$$ 0 \\ 1001 \\ 111 = 0100 \\ 1111 $$이것을 16진수로 나타내면 0x4f가 된다.정리하자면 10진수 7.75를 $ 0100 \\ 1111 $로 나타낼 수 있고 이것을 다시 16진수로 나타내면 0x4f이다. 4.4 1바이트 부동소수점의 표현 범위 표현할 수 있는 가장 작은 수(지수부0001) $1.0000 \\times = 0.0156256$ 표현할 수 있는 가장 큰 수(지수부 1110) $1.111 \\times = 240$ 단, 지수부 비트가 모두 0일때와 모두 1일때는 0.0, 정규화 불가능, 무한대, NaN 같은 특별한 상황이므로 제외한다. 4.5 1바이트 부동소수점의 정밀도7.75를 변환하는 과정에서 3비트의 가수부데이터에 1을 누락해 가면서 가수부 공간에 담았던 것을 기억할 것이다.1을 누락하게 되면 0x4f는 7.75를 완벽하게 표현하지 못하게 된다.$$1.111 \\times 2^2 = 1 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^{-1} = 7.5$$여기서 0.25만큼 차이가 나게되고, 그만큼 정밀도도 떨어지게 된다. 5. 정밀도에 대한 고찰5.1 엡실론실수 자료형에서 엡실론이란 1.0과 그 다음으로 표현 가능한 수 사이의 차이를 말한다. 12import syssys.float_info.epsilion 위 코드로 엡실론 값을 확인해 보자.배정도의 가수부는 52비트인 것을 기억할 것이다. 1.0을 배정도에 맞춰 표현하면$1.0000 ….. 0000(0:52개) \\times 2^0$배정도에서 1.0다음으로 표현할 수 있는 수는$1.0000 ….. 0000(0:51개) \\times 2^0$두 수의 차이는$1.0000 ….. 0000(0:51개) \\times 2^0$이 숫자를 10진수로 바꾸면 엡실론 값이 등장한다.$2.220446049250313 \\times 10^{-16}$ 5.2 엡실론과 정밀도엡실론을 이용하면 해당 실수 다음에 표현할 수 있는 수를 알아낼 수 있다.9.25라는 수를 부동소수점 방식으로 표현하면 $1.00101 \\times 2^3$이다.여기서 지수부분만 떼서 엡실론을 구하면 이 실수와 다음 표현 가능한 수 사이의 차이를 구할 수 있다.코드로 살펴보면, 123456789import sysep = sys.float_info.epsiliona= 9.25diff = (2**3)*epdiff&gt;&gt;1.7763568394002504e-15b = a + diffb&gt;&gt;&gt;9.250000000000002 0.000000000000002만큼 차이가 난다. 그렇다면 9.25에 diff보다 작은 값을 더하면 어떻게 될까?추측으로는 9.25가 나올 것 같다.확인해보자 12345a = 9.25half_diff = diff/2c = a + half_diffa == c&gt;&gt;&gt; True 추측과 같이 half_diff를 더하더라도 값의 변화가 없다.diff보다 작은 값을 더한 수를 부동소수점 방식에서는 표현할 수 없다는 말이다.다르게 말하자면 정밀도가 떨어진다는 말이다. 다음의 내용은 혼자서하는 괴발개발 블로그 https://aisolab.github.io/computer%20science/2018/08/07/CS_Real-number 에서 가져온 글이다.다음의 방법을 이용하면 상대오차(relative error) 가 엡실론보다 작으면 서로 같은 수라고 판단하는 function을 만듦으로써 위와 같은 문제를 해결할 수 있다. 1234a = 0.1 * 3b = 0.3print(a == b) 1False $$relative \\ error = {\\left\\vert x - y\\right\\vert \\over \\max(\\left\\vert x \\right\\vert , \\left\\vert y \\right\\vert)}$$ 123456789import sysdef is_equal(a, b): ep = sys.float_info.epsilon return abs(a - b) &lt;= max(abs(a), abs(b)) * epa = .1 * 3b = .3print(is_equal(a,b)) 1True","link":"/2019/01/19/float/"},{"title":"객체 지향 프로그램에 대해서 알아보자","text":"Reference : https://aisolab.github.io/computer%20science/2018/08/09/CS_Object-oriented-programming/ [김보섭님 블로그] 1. 프로그래밍 패러다임프로그래밍 패러다임으로는 다음 3가지가 대표적이다. 절차 지향 프로그래밍(procedural programming) 객체 지향 프로그래밍(object-oriented programming) 함수형 프로그래밍(fuctional programming) 2. 절차 지향 프로그래밍절차를 의미하는 procedure는 서브 루틴, 메서드, 함수라고 불린다.함수는 입력을 받아 연산을 하고 출력을 내보낸다. 함수를 한 번 정의해 두면 다시 호출해서 쓸 수 있고 이름으로 어떤 일을 하는지 쉽게 알 수 있다.이처럼 함수를 사용해 프로그래밍 하는 것을 절차 지향 프로그래밍이라고 한다. 3. 절차 지향으로 학급 성적 평가 프로그램 만들기우리가 담임 선생님이 되었다고 가정하고 엑셀에 저장된 학생들의 점수를 이용해 평균과 표준편차를 구하고 전체의 평균과 비교하여 평가하는 프로그램을 만들어 보자. 3.1 openpyxl모듈 설치하기pip install openpyxl 을 입력한다. 3.2 openpyxl 모듈로 데이터 읽어 들이기exam.xlsx name score greg 95 john 25 yang 50 timothy 15 melisa 100 thor 10 elen 25 mark 80 steve 95 anna 20 function.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from openpyxl import load_workbookfrom functools import reduceimport mathdef get_data_from_excel(filepath): wb = load_workbook(filename = filepath) ws = wb.active rows = ws.rows raw_data = {name_cell.value : score_cell.value for name_cell, score_cell in rows} scores = raw_data.values() return scoresdef get_average(scores): avrg = reduce(lambda score1, score2 : score1 + score2, scores) / len(scores) return avrgdef get_variance(scores, avrg): tmp = 0 for score in scores: tmp += (score - avrg)**2 else: var = tmp / len(scores) return vardef get_std_dev(var): std_dev = round(math.sqrt(var),1) return std_devdef evaluate_class(avrg, var, std_dev, total_avrg, total_std_dev): \"\"\" evaluate_class(avrg, var, std_dev, total_avrg, total_std_dev) -&gt; None Args: avrg : 반평균 var : 반분산 std_dev : 반표준편차 total_avrg : 학년평균 total_std_dev : 학년분산 \"\"\" print(\"평균:{}, 분산:{}, 표준편차:{}\".format(avrg, var, std_dev)) if avrg &lt; total_avrg and std_dev &gt; total_std_dev: print('성적이 너무 저조하고 학생들의 실력 차이가 너무 크다.') elif avrg &gt; total_avrg and std_dev &gt; total_std_dev: print('성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망!') elif avrg &lt; total_avrg and std_dev &lt; total_std_dev: print('학생들의 실력 차이는 크지 않지만 성적이 너무 저조하다. 주의 요망!') elif avrg &gt; total_avrg and std_dev &lt; total_std_dev: print('성적도 평균 이상이고 학생들의 실력 차이도 크지 않다.') main.py123456789101112131415161718from functions import *import argparse parser = argparse.ArgumentParser(prog = '평가프로그램', description = '엑셀에 저장된 학생들의 점수를 가져와 평균과 표준편차를 구하고, 학년 전체 평균과 비교하는 프로그램')parser.add_argument('filepath', type = str, help = '엑셀파일 저장경로')parser.add_argument('total_avrg', type = float, help = '학년평균')parser.add_argument('total_std_dev', type = float, help = '학년표준편차')args = parser.parse_args()def main(): scores = get_data_from_excel(filepath = args.filepath) avrg = get_average(scores = scores) var = get_variance(scores = scores, avrg = avrg) std_dev = get_std_dev(var = var) evaluate_class(avrg, var, std_dev, args.total_avrg, args.total_std_dev)if __name__ == '__main__': main() 메인 함수에는 책과 다른점이 있다. argparse부분이다. argparse 라이브러리를 임포트해서함수에 argument들을 넣었다. argument를 가지고 좀 더 세밀한 부분을 다뤄볼 수 있게 되었다. 이처럼 함수를 이용하면, 코드가 심플해지고, 쉽게 다시 불러와 사용할 수 있다.프로그램이 무슨 일을 하는지 알 수 있고, 한눈에 프로그램의 실행 흐름을 파악할 수 있다.절차 지향의 특징과 장점이라고 할 수 있겠다. 4. 객체 지향 프로그래밍객체 지향은 ‘현실 세계에 존재하는 객체를 어떻게 모델링할 것인가?’에 대한 물음에서 시작한다.데이터 사이언티스트들에게 익숙한 표현이 아닌가 싶다. 4.1 캡슐화현실 세계의 객체를 나타내려면 변수와 함수만 있으면 된다. 객체가 지니는 특성 값에 해당하는 것이 변수이고,행동 혹은 기능은 함수로 표현할 수 있다. 이처럼 현실 세계를 모델링하거나 프로그램을 구현하는 데 변수와 함수를 가진 객체를 이용하는 패러다임을 객체 지향 프로그래밍이라고 하며, 변수와 함수를 하나의 단위로 묶는 것을 캡슐화라고 한다. 4.2 클래스를 사용해 객체 만들기객체와 함수에 대해서 사람들은 어떤 중요한 의미를 부여하게 된다. 하지만 컴퓨터의 입장에서는 어떨까?컴퓨터는 의미가 전달이 되지 않는다. 메모리의 한 단위로만 저장될 뿐이다. 객체라는 메모리 공간을 할당한 다음 객체 안에 묶인 변수를 초기화하고 함수를 호출하는 데 필요한 것이 클래스일 뿐이다. 클래스는 객체를 생성해내는 템플릿이고(그 유명한 붕어빵 틀) 객체는 클래스를 이용해 만들어진 변수와 함수를 가진 메모리 공간이다. 둘은 서로 다른 존재이고 메모리 공간도 다르다. 객체와 매우 유사한 개념으로 인스턴스가 있다. 객체와 인스턴스의 차이점은 객체는 객체 자체에 초점을 맞춘 용어이고(붕어빵) 인스턴스는 이객체가 어떤 클래스에서 만들어졌는지에 초점을 맞춘 용어이다.(어떤 붕어빵 틀에서 나왔니) 사람이라는 클래스를 만들어보면서 이해해보면 쉬울 것이다.구현 코드는 아래와 같다.1234567891011121314class Person: def __init__(self, name, money): self.name = name self.money = money def give_money(self, other, money): other.get_money(money) self.money -= money def get_money(self, money): self.money += money def __str__(self): return 'name : {}, money : {}'.format(self.name, self.money) 12greg = Person('greg', 5000)john = Person('john', 2000) 12345print(greg, john)name : greg, money : 5000 name : john, money : 2000greg.give_money(john, 2000)print(greg, john)name : greg, money : 3000 name : john, money : 4000 4.3 파이썬의 클래스4.2에서 구현한 클래스를 가져와서 살펴보자12345678type(Person.__init__)= &lt;class 'function'&gt;type(Person.give_momey)= &lt;class 'function'&gt;type(Person.get_money)= &lt;class 'function'&gt;type(Person.show)= &lt;class 'function'&gt; 모두 함수라는 충격적인 결과가 나온다. 이번에는 객체가 가진 메서드를 살펴보자123456type(g.give_money)= &lt;class 'method'&gt;type(g.get_meney)= &lt;class 'method'&gt;type(g.show)= &lt;class 'method'&gt; 객체 g의 메서드는 메서드인 것을 알 수 있다. 비슷한 것 같은데 둘의 차이는 무엇일까? 1234567dir(g.give_money)g.give_money.__func__g.give_money.__self__g.give_money.__self__ is g 위의 코드를 실행 시켜보면 차이를 확인해 볼 수 있다.g가 가진 메서드의 속성을 dir을 통해 확인해보면, __func__, __self__가 등장하는 것을 볼 수 있다. __self__를 확인해 보면 Person객체라고 나온다. __func__는 또한 Person클래스의 give_money()함수라는 것을 확인할 수 있고, __self__가 이 메소드를 가진 객체 자신을 참조하고 있다는 것도 알 수 있다. 객체에서 메서드를 호출할 때 self를 전달하지 않아도 되는 이유를 여기서 알 수 있게 된다. 메서드 내부에 함수와 객체의 참조를 가지고 있으므로, 함수에 직접 객체의 참조를 전달할 수 있기 때문이다. [혼자서하는 괴발개발 블로그]https://aisolab.github.io/computer%20science/2018/08/09/CS_Object-oriented-programming/classmethod와 staticmethod를 한눈에 정리가능한 코드가 있어서가져와봤다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person: # 여기에 class variable (또는 class member) # instance 모두가 공유하는 동일한 값 # instance를 생성하지않고도, class만 선언한 상태에서 호출이 가능하다. # oop에서 global variable을 대체하기위하여 사용 __whole_population = 0 # name mangling technique 사용, 외부에서 ## Person.__whole_population으로 접근 불가 ## Person._Person__whole_population으로 접근 가능 # class method # oop에서 global에 선언된 function을 대체하기위해 사용 # 대체 생성자를 만들 때, 더 많이씀 (여긴 대체생성자 구현하지 않음) @classmethod def __birth(cls): cls.__whole_population += 1 @staticmethod def check_population(): return Person.__whole_population # instance method def __init__(self, name, money): # 생성자(constructor) Person.__birth() # instance variable (또는 instance member) # instance마다 값이 다른 변수, instance가 가지는 고유한 값 # 여기에서는 self.name, self.age self.name = name self.money = money def get_money(self, money): self.money += money def give_money(self, other, money): # message passing # 다른 인스턴스(객체)랑 상호작용을 할 때, 상대 인스턴스(객체)의 인스턴스 변수를 바꿔야한다면 other.get_money(money) # 이렇게하세요 # other.money += money 이렇게하지마세요 self.money -= money def __str__(self): return '{} : {}'.format(self.name, self.money) 주석처리도 너무 잘되어 있기 때문에 쭉 보고 따라 쳐보면서 이해하면 아주 좋을 것 같다. 클래스 메서드의 특징 중 하나는 인스턴스를 만들지 않고도 불러낼 수 있다는 것이다.12# 클래스 메소드는 인스턴스를 생성하지않고도 호출할 수 있다.print(Person.check_population()) 10 만들어놓은 클래스를 사용해보자.1234567891011121314151617# 클래스 변수는 인스턴스간에 모두 공유한다.# 인스턴스를 통해서도 클래스 변수나 클래스 메소드를 호출할 수 있다.mark = Person('mark', 5000)greg = Person('greg', 3000)steve = Person('steve', 2000)print(Person.check_population())print(Person._Person__whole_population)print(mark._Person__whole_population)print(greg._Person__whole_population)print(steve._Person__whole_population)steve._Person__birth()print(mark._Person__whole_population)print(greg._Person__whole_population)print(steve._Person__whole_population) 1234567833333444 마크와 그렉 스티브가 인스턴스로 만들어졌다. 만들어지자마자 클래스메서드의 __birth가 실행되어서인구가 총 3명이 된다.스티브 인스턴스를 통해 클래스 메서드로의 접근이 가능해서인구가 4가 되었고인스턴스로 접근해 전역변수 __whole_population을 요청하면 4가 나오게 된다. 4.4 객체 지향으로 은행 입출금 프로그램 만들기123456789101112131415161718192021222324252627282930313233343536class Account: __num_acnt = 0 @staticmethod def get_num_acnt(): return Account.__num_acnt def __init__(self, name, money): self._user = name self._balance = money Account.__num_acnt += 1 def deposit(self, money): assert money &gt; 0, '금액이 음수입니다.' self._balance += money def withdraw(self, money): assert money &gt; 0, '금액이 음수입니다.' if self._balance &gt;= money: self._balance -= money else: pass def transfer(self, other, money): assert money &gt; 0, '금액이 음수입니다.' self.withdraw(money) if self._balance &gt;= 0: other.deposit(money) return True else: return False def __str__(self): return 'user : {}, balance :{}'.format(self._user, self._balance) 4.5 정보 은닉결론부터 말하자면, 파이썬은 정보 은닉을 지원하지 않는다. 정보은닉은 캡슐화할때 사용된다. 캡슐화하는 과정에서 어떤 멤버와 메서드는 공개해서 유저 프로그래머가 사용할 수 있게 해야하고, 어떤 멤버와 메서드는 숨겨서, 접근하지 못하도록 해야한다. 캡슐화는 그래서 정보 은닉까지 포함하는 개념이다. 파이썬이 그나마 제공하는 방법은 두 가지이다. 숨기려는 멤버 앞에 언더바 두개 붙이기(name mangling) 프로퍼티 기법 첫번째 방법을 사용해보자123456789101112class Account: def __init__(self, name, money): self.__name = name self.__balance = money def get_balance(self): return self.__balance def set_balance(self, new_bal): if new_bal &lt; 0: return self.__balance = new_bal 12my_acnt = Account(name = 'hyubyy', money = 5000)print(my_acnt.__dict__) 1{'_Account__name': 'hyubyy', '_Account__balance': 5000} 내 계좌에 5000을 넣어놨다.12my_acnt.__balance = -5000print(my_acnt.get_balance()) 내 계좌에 직접 접근해서 -5000을 하는 코드이다. 그런데print를 하게되면 결과는 5000이 나오게된다.어? 정보 은닉이 된게 아닐까?1print(my_acnt.__dict__) 1{'_Account__name': 'hyubyy', '_Account__balance': 5000, '__balance': -5000} -5000은 __balance라는 형태로 저장되어 있다. 숨겨진 형태로 저장될 때_Account__balance로 원래의 5000이 따로 저장된다. 클래스 안에서 멤버 앞에 언더바를 두 개 붙이면 이 멤버는 객체가 만들어질 때 이름이 변한다. 하지만 __dict__로 확인이 가능해서, 언제든지 접근해서 변경할 수 있다.1my_acnt._Account__balance = 8888 1print(my_acnt.__dict__) 1{'_Account__name': 'hyubyy', '_Account__balance': 8888, '__balance': -5000} 다음은 프로퍼티 기법이다.1234567891011121314151617181920class Account: def __init__(self, name, money): self.__name = name self.balance = money @property def balance(self): # getter function return self.balance @balance.setter def balance(self, money): # setter function if money &lt; 0: return self._balance = money if __name__ == '__main__': my_acnt = Account('greg', 5000) my_acnt.balance = -3000 print(my_acnt.balance) 실행 결과는 5000이다. 놀랍게도 balance가 2000으로 나오지 않았다. 위의 코드에서 특이한 점이 있는데 @property와 @balance.setter라는 부분이다.@property를 붙여주면 이 함수는 getter 함수가 되며, @balance.setter는 setter함수로 사용된다.따라서, my_acnt 객체에는 balance라는 멤버가 없다. balance라는 이름의 getter와 setter밖에 존재 하지 않는다. my_acnt.balance = -3000은 값을 변경하는 것처럼 보이지만, 실제로는 setter가 실행되고 그 결과로 _balance값은 변경되지 않는다. 하지만 프로퍼티 기법 역시 유저가 접근하는 것을 막을 수는 없다.마찬가지로1my_acnt._balance = -3000 으로 바꿔버리면 그만이기 때문이다.이처럼 파이썬은 완벽한 정보 은닉을 제공하지 않는다. 5. 객체지향으로 다시 만드는 학급 성적 평가 프로그램이제 사용자 프로그램을 더 심플하게 작성할 수 있게 되었다.statistics.py1234567891011121314151617181920212223from functools import reduceimport mathclass Stat: def get_average(self, scores): avrg = reduce(lambda score1, score2 : score1 + score2, scores) / len(scores) return avrg def get_variance(self, scores, avrg): tmp = 0 for score in scores: tmp += (score - avrg)**2 else: var = tmp / len(scores) return var def get_std_dev(self, var): std_dev = round(math.sqrt(var),1) return std_dev datahandler.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from openpyxl import load_workbookfrom statistics import Statclass DataHandler: evaluator = Stat() @classmethod def get_data_from_excel(cls, filepath): wb = load_workbook(filename = filepath) ws = wb.active rows = ws.rows raw_data = {name_cell.value : score_cell.value for name_cell, score_cell in rows} scores = raw_data.values() return scores def __init__(self, filepath): self.scores = DataHandler.get_data_from_excel(filepath = filepath) self.cache = {'scores' : self.scores} def get_average(self): if 'average' not in self.cache.keys(): self.cache.update({'average' : DataHandler.evaluator.get_average(self.cache.get('scores'))}) return self.cache.get('average') else: return self.cache.get('average') def get_variance(self): if 'variance' not in self.cache.keys(): self.cache.update({'variance' : DataHandler.evaluator.get_variance(self.cache.get('scores'), self.get_average())}) return self.cache.get('variance') else: return self.cache.get('variance') def get_std_dev(self): if 'std_dev' not in self.cache.keys(): self.cache.update({'std_dev' : DataHandler.evaluator.get_std_dev(self.get_variance())}) return self.cache.get('std_dev') else: return self.cache.get('std_dev') def evaluate_class(self, total_avrg, total_std_dev): avrg = self.get_average() var = self.get_variance() std_dev = self.get_std_dev() print(\"평균:{}, 분산:{}, 표준편차:{}\".format(avrg, var, std_dev)) if avrg &lt; total_avrg and std_dev &gt; total_std_dev: print('성적이 너무 저조하고 학생들의 실력 차이가 너무 크다.') elif avrg &gt; total_avrg and std_dev &gt; total_std_dev: print('성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망!') elif avrg &lt; total_avrg and std_dev &lt; total_std_dev: print('학생들의 실력 차이는 크지 않지만 성적이 너무 저조하다. 주의 요망!') elif avrg &gt; total_avrg and std_dev &lt; total_std_dev: print('성적도 평균 이상이고 학생들의 실력 차이도 크지 않다.') main.py 123456789101112131415from datahandler import DataHandlerimport argparse parser = argparse.ArgumentParser(prog = '평가프로그램', description = '엑셀에 저장된 학생들의 점수를 가져와 평균과 표준편차를 구하고, 학년 전체 평균과 비교하는 프로그램')parser.add_argument('filepath', type = str, help = '엑셀파일 저장경로')parser.add_argument('total_avrg', type = float, help = '학년평균')parser.add_argument('total_std_dev', type = float, help = '학년표준편차')args = parser.parse_args()def main(): datahandler = DataHandler(filepath = args.filepath) datahandler.evaluate_class(total_avrg = args.total_avrg, total_std_dev = args.total_std_dev)if __name__ == '__main__': main()` 유저 프로그램인 main.py script를 실행시키면 아래와 같다.123456789101112$ python main.py --helpusage: 평가프로그램 [-h] filepath total_avrg total_std_dev엑셀에 저장된 학생들의 점수를 가져와 평균과 표준편차를 구하고, 학년 전체 평균과 비교하는 프로그램positional arguments: filepath 엑셀파일 저장경로 total_avrg 학년평균 total_std_dev 학년표준편차optional arguments: -h, --help show this help message and exit 1$ python main.py ./class_1.xlsx 50 25 12평균:51.5, 분산:1240.25, 표준편차:35.2성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망!","link":"/2019/01/28/oop/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"cs","slug":"cs","link":"/tags/cs/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"oop","slug":"oop","link":"/tags/oop/"},{"name":"python,cs,class","slug":"python-cs-class","link":"/tags/python-cs-class/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"cs","slug":"cs","link":"/categories/cs/"},{"name":"cs","slug":"python/cs","link":"/categories/python/cs/"},{"name":"python","slug":"cs/python","link":"/categories/cs/python/"}]}